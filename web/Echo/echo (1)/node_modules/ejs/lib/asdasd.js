function () {
    var src;
    var fn;
    var opts = this.opts;
    var prepended = '';
    var appended = '';
    var escapeFn = opts.escapeFunction;
    var ctor;

    if (!this.source) {
      this.generateSource();
      prepended += '  var __output = [], __append = __output.push.bind(__output);' + '\n';
      if (opts.outputFunctionName) {
        prepended += '  var ' + opts.outputFunctionName + ' = __append;' + '\n';
      }
      if (opts._with !== false) {
        prepended +=  '  with (' + opts.localsName + ' || {}) {' + '\n';
        appended += '  }' + '\n';
      }
      appended += '  return __output.join("");' + '\n';
      this.source = prepended + this.source + appended;
    }

    if (opts.compileDebug) {
      src = 'var __line = 1' + '\n'
        + '  , __lines = ' + JSON.stringify(this.templateText) + '\n'
        + '  , __filename = ' + (opts.filename ?
        JSON.stringify(opts.filename) : 'undefined') + ';' + '\n'
        + 'try {' + '\n'
        + this.source
        + '} catch (e) {' + '\n'
        + '  rethrow(e, __lines, __filename, __line, escapeFn);' + '\n'
        + '}' + '\n';
    }
    else {
      src = this.source;
    }

    if (opts.client) {
      src = 'escapeFn = escapeFn || ' + escapeFn.toString() + ';' + '\n' + src;
      if (opts.compileDebug) {
        src = 'rethrow = rethrow || ' + rethrow.toString() + ';' + '\n' + src;
      }
    }

    if (opts.strict) {
      src = '"use strict";\n' + src;
    }
    if (opts.debug) {
      console.log(src);
    }

    try {
      if (opts.async) {
        // Have to use generated function for this, since in envs without support,
        // it breaks in parsing
        try {
          ctor = (new Function('return (async function(){}).constructor;'))();
        }
        catch(e) {
          if (e instanceof SyntaxError) {
            throw new Error('This environment does not support async/await');
          }
          else {
            throw e;
          }
        }
      }
      else {
        ctor = Function;
      }
      console.log(src);console.log(opts.localsName + ', escapeFn, include, rethrow');fn = new ctor(opts.localsName + ', escapeFn, include, rethrow', src);console.log(fn.toString());
    }
    catch(e) {
      // istanbul ignore else
      if (e instanceof SyntaxError) {
        if (opts.filename) {
          e.message += ' in ' + opts.filename;
        }
        e.message += ' while compiling ejs\n\n';
        e.message += 'If the above error is not helpful, you may want to try EJS-Lint:\n';
        e.message += 'https://github.com/RyanZim/EJS-Lint';
        if (!e.async) {
          e.message += '\n';
          e.message += 'Or, if you meant to create an async function, pass async: true as an option.';
        }
      }
      throw e;
    }

    if (opts.client) {
      fn.dependencies = this.dependencies;
      return fn;
    }

    // Return a callable function which will execute the function
    // created by the source-code, with the passed data as locals
    // Adds a local `include` function which allows full recursive include
    var returnedFn = function (data) {
      var include = function (path, includeData) {
        var d = utils.shallowCopy({}, data);
        if (includeData) {
          d = utils.shallowCopy(d, includeData);
        }
        return includeFile(path, opts)(d);
      };
      console.log(include.toString());return fn.apply(opts.context, [data || {}, escapeFn, include, rethrow]);
    };
    returnedFn.dependencies = this.dependencies;
    return returnedFn;
  }

  //returnedFn;
  function (data) {
    var include = function (path, includeData) {
      var d = utils.shallowCopy({}, data);
      if (includeData) {
        d = utils.shallowCopy(d, includeData);
      }
      return includeFile(path, opts)(d);
    };
    console.log(include.toString());return fn.apply(opts.context, [data || {}, escapeFn, include, rethrow]);
  }

  function anonymous(locals, escapeFn, include, rethrow
    ) {
    var __line = 1
      , __lines = "<%=text %>\n"
      , __filename = "/home/eethan1/Projects/EOFxEDU_CTF/web/Echo/echo (1)/views/echo.ejs";
    try {
      var __output = [], __append = __output.push.bind(__output);
      with (locals || {}) {
        ; __append(escapeFn(text ))
        ; __append("\n")
        ; __line = 2
      }
      return __output.join("");
    } catch (e) {
      rethrow(e, __lines, __filename, __line, escapeFn);
    }


    [
      'delimiter',    'scope',
      'context',      'debug',
      'compileDebug', 'client',
      '_with',        'rmWhitespace',
      'strict',       'filename',
      'async',        'cache'
    ]
    function anonymous(locals, escapeFn, include, rethrow
      ) {
      var __line = 1
        , __lines = "<%=text %>\n"
        , __filename = "/home/eethan1/Projects/EOFxEDU_CTF/web/Echo/echo (1)/views/echo.ejs";
      try {
        var __output = [], __append = __output.push.bind(__output);
        with (locals || {}) {
          ; __append(escapeFn(text ))
          ; __append("\n")
          ; __line = 2
        }
        return __output.join("");
      } catch (e) {
        rethrow(e, __lines, __filename, __line, escapeFn);
      }
      
      function (path, includeData) {
              var d = utils.shallowCopy({}, data);
              if (includeData) {
                d = utils.shallowCopy(d, includeData);
              }
              return includeFile(path, opts)(d);
            }
      
      [
        '/home/eethan1/Projects/EOFxEDU_CTF/web/Echo/echo (1)/views/echo.ejs',
        {
          settings: {
            'x-powered-by': true,
            etag: 'weak',
            'etag fn': [Function: generateETag],
            env: 'development',
            'query parser': 'extended',
            'query parser fn': [Function: parseExtendedQueryString],
            'subdomain offset': 2,
            'trust proxy': false,
            'trust proxy fn': [Function: trustNone],
            view: [Function: View],
            views: '/home/eethan1/Projects/EOFxEDU_CTF/web/Echo/echo (1)/views',
            'jsonp callback name': 'callback'
          },
          text: { toString: [Object] },
          a: [ [Object] ],
          _locals: [Object: null prototype] {},
          cache: false
        },    